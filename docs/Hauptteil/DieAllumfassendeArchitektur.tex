\chapter{Die allumfassende Architektur}
\label{chap:die-allumfassende-architektur}

\section{Auswertung vorhandener Produkte}
% Qlik, Tableau, Grafana => Vergleichem

\section{Workflow of a Data Scientist}
% Collection Exploration Mugling Modeling Validation Reporting

\section{Mögliche Veranschaulichungen von Daten}
% Aktuelle Modelle: Measures and Dimensions

\section{Mircoservices}

\subsection{Microfrontend}
Domain Driven Development also in Frontend.

Aufteilung in Module, die während der laufzeit geladen werden.
Seite 171 in Buch (Eberhard Wolff Microservices) befasst sich mit dem
Thema, wenn auch nicht auf das dynamische Laden eingegangen wird.
"Das Deployment der SPA ist meistens nur als vollständige Anwendung möglich."
Neuer Ansatz für unabhängiges Deployment!

-> Auch Problem: Deployment Monolith -> Separation der Deployment Vorgänge

-> "Wenn in einem Microservice ein Feature umgesetzt wird, das auch Änderungen
in der Client-Anwendung benötigt, kann diese Änderung nicht durch eine neue
Version des Microservice alleine ausgerollt werden. Es muss auch eine neue Version
der Client-Anwendung ausgeliefert werden." Seite 176.  (Eberhard Wolff Microservices)
Absatz 3.

Deployment abhängigkeiten verringern!

SOAP Schnittstelle zwischen Frontend Chart Plugins und Frontend Arrangement Software!
Weniger bis garkeine Abhängigkeit von Implementierungsdetails

Problem: Steigende Komplexität der Anwendung.

\section{Die Schnittstellengestaltung}
% sehr wichtig, abstraktion

\section{Die Aufteilung der Logik}
\label{sec:die-aufteilung-der-logic}
Separation of Concerns, etwa Trennung der Zuständigkeiten

\section{Die Datenstruktur}
Die Softwarearchitektur sollte so flexibel wie möglich mit unterschiedlichen Datenstrukturen
umgehen können. Dennoch benötigt es eine klar definierte Schnittstelle zu den Plugins,
welche für die Datenvisualisierung verantwortlich sind. Aber wie sollte nun eine solche flexible 
und dennoch klar definierte Datenstruktur aussehen?

Schauen wir uns zuerst einmal die bereits existierenden Lösungen verwandter Anwendungen an. Drei der
wohl bekanntesten Business Intelligence Lösungen im Bereich der Datenvisualisierung sind Qlik Sense
von Qliktech, Tableau Public von Tablea Software und PowerBI von Microsoft. In der Business Intelligence
Welt werden Mengen von Elementen oft in Maße (Measures) und Dimensionen (Dimensions) unterteilt. Unter Maße versteht
man numerische Elemente einer Menge, Dimensionen hingegen stellen kategorische Elemente dar. Ein Maß
ist beispielsweise die Anzahl verkaufter Produkte, eine Dimension das Land, in welchem die Produkte verkauft worden
sind. Bei einem Balkendiagram kann demnach die Länge der Balken die Anzahl der verkauften Produkte
widerspiegeln. Ein Balken representiert das Land, in dem das Produkt verkauft wurde.


Georg Cantor: "Unter einer Menge verstehen wir jede Zusammenfassung M von bestimmten wohlunterschiedenen
Objekten (m) unserer Anschauung oder unseres Denkens (welche die Elemente von M genannt werden) zu einem Ganzen.
... Die Objekte, die in einer Menge enthalten sind, nennt man Elemente der Menge."

Das bekannteste Datenbankmodel ist das relationale Datenbankmodel. In vielen Statistikanwendungen findet
man möglichkeiten
Da das relationale Datenbankenmodel das bekannteste ist, orientieren sich viele Statistikanwendungen an diesem.

Die meisten Statistikanwendungen haben klare Beziehungen zu Relationalen Datenbanksystemen. 

Die Abbildung von Mehrdimenstionaler Daten in einer eindimensionalen Welt.



% zwei möglich eoperationen nötig, alle beziehungen in einer tabelle darstellen,
% zeilen unendliche Teilmengen hinzufügen und die Sortieren
% List processing???

Da die Daten und deren Beziehungen von Anwendungsfall zu Anwendungsfall
variieren, gilt es eine klar definierte Datenstruktur zu finden, die
die gängigsten Anwendungsfälle abdecken kann. 

% Show dashboard json structure using maybe css grid
% and data structure to pass to plugins
% many to many to many relations???



In Tableau und Qlik Sense hat man die Möglichkeit, aus einer ausklappbaren Auswahl an der Seite der
Anwendung, Maße und Dimensionen durch Drag and Drop verschiedenen Diagrammen zuzuordnen. 

\section{Das Design des Datenflusses}
\label{sec:das-design-des-datenflusses}

\section{Die Definition der Schnittstellen}
\label{sec:die-definition-der-schnittstellen}

\section{Die Wahl der Technologien}

\subsection{React}
Dan Abramov Representational components vs container components => actual view and controller


\section{Die Bewahrung der Offenheit gegenüber der Veränderung}
\label{sec:die-bewahrung-der-offenheit-gegenueber-der-veraenderung}

\subsection{Die Änderung des Quellcodes}

\subsection{Das stetige Aktualisieren der ausgelieferten Software}
Probleme: cookies verändern sich, serviceworker verändert sich, neue Felder in der Datenbank
Frontend und Backend etc, also allen verschiedenen Services


\begin{listing}
    \label{lst:HelloJSX}
    \caption{Ein einfaches JSX Beispiel}
    \inputminted{jsx}{snippets/examples/Welcome.jsx}
\end{listing}

\begin{listing}
    \label{lst:Golang}
    \caption{Ein einfaches Golang Beispiel}
    \inputminted{go}{snippets/examples/hello.go}
\end{listing}

\newpage

\begin{figure}
    \label{figure:test}
    \includegraphics[scale=0.2]{img/HTW}
    \caption{Test}
\end{figure}

\begin{figure}
    \label{figure:beispiel}
    \includegraphics[scale=0.2]{img/HTW}
    \caption{Beispiel}
\end{figure}

\section{Horizontale Skalierung ermöglichen}
% stateless backend, no sessions etc.

\section{Die Zustandsverwaltung im Frontend}
Anfangs habe ich die Zustandsverwaltung der Dashboards im Frontend wie
folgt entworfen. Ein großes JavaScript Object beinhaltet eine Baumstruktur
von verschiedenen Diagrammen. Je nach Anordnung befindet sich als Kindknoten
ein Array von weiteren Kindknoten oder ein Diagramm. Jedes Diagram speichert
die Art des Diagramms sowie Einstellungen des Diagramm Containers sowie des
Diagramms. Die Diagramme sind ausgelagerte Plugins mit einer definierten
Schnittstelle. Sie können eigene Einstellungen speichern. Beispiele dafür
können eine kategorische Auswahl in einem Diagramm sein, die für den Benutzer
relevant ist. Ein Benutzer will beispielsweise nur Ausfallstatistiken einer
bestimmten Schicht beobachten. Um nicht jedes mal die gleichen Einstellungen
durchzuführen, hat er so die möglichkeit jede zu persistieren. Außerdem sollte
die Komponente, welche so ein Diagramm Plugin beinhaltet, nur bestimmte Daten
in einer besimmten Form weiterreichen. Diese Einstellungen gilt es auch zu speichern.
Anfangs speicherte ich die Einstellungen direkt innerhalb des großen JavaScript Objekts.
Ein rekursiv implementierter Algorithmis iterierte durch das ganze Objekt und lud so 
je nach Einstellung das passende Diagramm und dessen Einstellungsparameter. Ein Problem,
was sich erst nach geraumer Zeit entwickelte, war die Anzahl der Aktualisierungen
der graphischen Benutzeroberfläche. Bei jeder noch so kleinen Einstellungsaktualisierung,
renderte das ganze Dashboard komplett neu. Da die Diagramme agil in der Laufzeit aus dem
Redis Zwischenspeicher und Später aus dem Browser Cache geladen werden, wurde bei jeder
kleinen Änderung Code-Module neu aus dem Cache geladen. All diese Nebenwirkungen
verursachten einen großen Performanceverlust. Die initiale Idee, rekursiv durch
eine Baumstruktur zu iterieren, um die Anordnung der Diagramme in einem Dashboard
darzustellen ist ansich nicht das Problem. Vielmehr sollte die Einstellungslogik klar
von der der Anordnung getrennt werden.  

Ein möglicher Lösungsansätz ist das getrennte speichern der Einstellungen jedes
einzelnen Diagramms in der Datenbank. Findet der Algorithmus beim iterieren durch
die Baumstruktur so ein Diagramm, fragt er anhand der dort gespeicherten 
Identifikationsnummer bei der Datenbank an, welche Einstellungen dieses Diagramm
beinhaltet. Dieser Ansatz hat aber zum einen den Nachteil der erhöhten Anzahl an
Datenbankanfragen, zum anderen wird in diesem Fall der Fremdschlussel, welcher auch
die Eintrag des Diagramms zeigt, nicht direkt in einem Datenbankfeld sondern in einer
JSON struktur gespeichert. Die JSON struktur wird zwar selbst auch in der Datenbank 
gespeichert, allerdings zerstört diese Art von Reference die Grundprinzipien des
relationalen Datenbankmodells. Jeder Foreign Key sollte ein eigenes Feld besitzen.
Ein hierarchisches Datenbankmodell würde dieses Problem lösen, allerdings aber auch
ein weiteres Datenbankmodel in die Architektur hinzufügen, welches die Komplexität
erhöhen würde. Außerdem benötigt man immer den ganzen Dashboardaufbau, weshalb es
auch Sinn macht diesen als ganzen zu speichern. Dies erhöht außerdem die Flexibilität
der Datenstruktur während der Entwicklung.

Ein weiterer Lösungsansatz ist eine verbesserte Zustandsverwaltung im Frontend. In der
Regel wird hierfür im Fall der JavaScript Frontend Bibliothek React die Bibliothek
Redux zur Zustandsverwaltung verwendet. Dies ist historisch gewachsen, da React Anfangs
nur bei den klassenbasierten Komponenten eine Zustandsverwaltung von Haus aus
anbot. Bei der React Conf 2018 wurde von Dan Abramov und Ryan Florence ein neues
Konzept der React Hooks vorgestellt.
\footnote{Ein Mitschnitt der Vorträge findet man auf Youtube \cite{}}

Durch die Verwendung des useContext Hooks konnten
so nun auch funktionale Komponenten die Context API, eine eigene Zustandsverwaltung von React implementieren.
Um die Komplexität der Applikation so gering wie möglich zu halten, entschied ich mich
primär zur Zustandsverwaltung die Context API zu verwenden.





